# Visualisation Ultra-AvancÃ©e pour StratÃ©gie Straddle

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
import pandas as pd
import numpy as np
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

plt.style.use('dark_background')
sns.set_palette("husl")

class UltraVisualization:
    """Visualisations ultra-avancÃ©es pour analyse de performance"""
    
    def __init__(self):
        self.fig_size = (20, 12)
        self.colors = {
            'profit': '#00ff88',
            'loss': '#ff4444',
            'neutral': '#888888',
            'hedge': '#ffaa00',
            'background': '#1a1a1a',
            'grid': '#333333'
        }
    
    def create_ultra_performance_dashboard(self, data, results, output_dir='output'):
        """CrÃ©e un dashboard ultra-complet de performance"""
        print("ðŸ“Š GÃ©nÃ©ration dashboard ultra-avancÃ©...")
        
        # Configuration figure principale
        fig = plt.figure(figsize=(24, 16))
        fig.patch.set_facecolor(self.colors['background'])
        
        # 1. Ã‰volution du capital (graphique principal)
        ax1 = plt.subplot(3, 3, (1, 3))
        self._plot_capital_evolution(ax1, results)
        
        # 2. Distribution des PnL
        ax2 = plt.subplot(3, 3, 4)
        self._plot_pnl_distribution(ax2, results)
        
        # 3. Win Rate dans le temps
        ax3 = plt.subplot(3, 3, 5)
        self._plot_rolling_winrate(ax3, results)
        
        # 4. Drawdown analysis
        ax4 = plt.subplot(3, 3, 6)
        self._plot_drawdown_analysis(ax4, results)
        
        # 5. VolatilitÃ© vs Performance
        ax5 = plt.subplot(3, 3, 7)
        self._plot_volatility_performance(ax5, data, results)
        
        # 6. Hedge Opportunities
        ax6 = plt.subplot(3, 3, 8)
        self._plot_hedge_analysis(ax6, results)
        
        # 7. Statistiques rÃ©capitulatives
        ax7 = plt.subplot(3, 3, 9)
        self._plot_performance_metrics(ax7, results)
        
        plt.tight_layout(pad=3.0)
        
        # Sauvegarde
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f'{output_dir}/ultra_straddle_dashboard_{timestamp}.png'
        plt.savefig(filename, dpi=300, bbox_inches='tight', 
                   facecolor=self.colors['background'], edgecolor='none')
        print(f"âœ… Dashboard sauvegardÃ©: {filename}")
        
        plt.show()
        
        # CrÃ©er d'autres visualisations spÃ©cialisÃ©es
        self._create_trade_analysis_chart(results, output_dir, timestamp)
        self._create_risk_analysis_chart(results, output_dir, timestamp)
        
        return filename
    
    def _plot_capital_evolution(self, ax, results):
        """Graphique d'Ã©volution du capital ultra-dÃ©taillÃ©"""
        if not results['daily_pnl']:
            return
        
        df = pd.DataFrame(results['daily_pnl'])
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        
        # Courbe principale du capital total
        ax.plot(df['timestamp'], df['total_value'], 
               color=self.colors['profit'], linewidth=3, label='Capital Total', alpha=0.9)
        
        # Zone de profit/perte
        initial_capital = df['total_value'].iloc[0] if len(df) > 0 else 10000
        ax.fill_between(df['timestamp'], df['total_value'], initial_capital,
                       where=(df['total_value'] >= initial_capital),
                       color=self.colors['profit'], alpha=0.3, label='Zone Profit')
        ax.fill_between(df['timestamp'], df['total_value'], initial_capital,
                       where=(df['total_value'] < initial_capital),
                       color=self.colors['loss'], alpha=0.3, label='Zone Perte')
        
        # Ligne de capital initial
        ax.axhline(y=initial_capital, color=self.colors['neutral'], 
                  linestyle='--', alpha=0.7, label='Capital Initial')
        
        # Marqueurs des trades
        if results['trades']:
            trades_df = pd.DataFrame(results['trades'])
            trades_df['exit_time'] = pd.to_datetime(trades_df['exit_time'])
            
            wins = trades_df[trades_df['pnl'] > 0]
            losses = trades_df[trades_df['pnl'] <= 0]
            
            if not wins.empty:
                ax.scatter(wins['exit_time'], [initial_capital] * len(wins), 
                          color=self.colors['profit'], s=100, alpha=0.8, 
                          marker='^', label=f'Trades Gagnants ({len(wins)})')
            
            if not losses.empty:
                ax.scatter(losses['exit_time'], [initial_capital] * len(losses), 
                          color=self.colors['loss'], s=100, alpha=0.8, 
                          marker='v', label=f'Trades Perdants ({len(losses)})')
        \n        ax.set_title('ðŸš€ Ã‰volution Ultra du Capital', fontsize=16, fontweight='bold', color='white')\n        ax.set_xlabel('Temps', color='white')\n        ax.set_ylabel('Capital ($)', color='white')\n        ax.legend(loc='upper left')\n        ax.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax.tick_params(colors='white')\n        \n        # Format des dates\n        ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))\n        ax.xaxis.set_major_locator(mdates.WeekdayLocator())\n        \n        # Annotations importantes\n        if len(df) > 0:\n            final_value = df['total_value'].iloc[-1]\n            total_return = ((final_value - initial_capital) / initial_capital) * 100\n            ax.annotate(f'Rendement: {total_return:.1f}%', \n                       xy=(0.02, 0.98), xycoords='axes fraction',\n                       fontsize=12, fontweight='bold', \n                       color=self.colors['profit'] if total_return > 0 else self.colors['loss'],\n                       bbox=dict(boxstyle='round,pad=0.5', facecolor='black', alpha=0.7))\n    \n    def _plot_pnl_distribution(self, ax, results):\n        \"\"\"Distribution des PnL avec analyse statistique\"\"\"\n        if not results['trades']:\n            return\n        \n        pnl_data = [t['pnl_pct'] for t in results['trades']]\n        \n        # Histogramme principal\n        ax.hist(pnl_data, bins=20, alpha=0.7, color=self.colors['neutral'], \n               edgecolor='white', linewidth=1)\n        \n        # Lignes statistiques\n        mean_pnl = np.mean(pnl_data)\n        median_pnl = np.median(pnl_data)\n        \n        ax.axvline(mean_pnl, color=self.colors['profit'], linestyle='-', \n                  linewidth=2, label=f'Moyenne: {mean_pnl:.1f}%')\n        ax.axvline(median_pnl, color=self.colors['hedge'], linestyle='--', \n                  linewidth=2, label=f'MÃ©diane: {median_pnl:.1f}%')\n        ax.axvline(0, color=self.colors['loss'], linestyle=':', \n                  linewidth=2, alpha=0.7, label='Break-even')\n        \n        ax.set_title('ðŸ“Š Distribution des PnL', fontsize=14, fontweight='bold', color='white')\n        ax.set_xlabel('PnL (%)', color='white')\n        ax.set_ylabel('FrÃ©quence', color='white')\n        ax.legend()\n        ax.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax.tick_params(colors='white')\n    \n    def _plot_rolling_winrate(self, ax, results):\n        \"\"\"Win rate glissant dans le temps\"\"\"\n        if not results['trades'] or len(results['trades']) < 5:\n            return\n        \n        trades_df = pd.DataFrame(results['trades'])\n        trades_df['exit_time'] = pd.to_datetime(trades_df['exit_time'])\n        trades_df = trades_df.sort_values('exit_time')\n        trades_df['is_win'] = trades_df['pnl'] > 0\n        \n        # Win rate glissant sur 10 trades\n        window = min(10, len(trades_df))\n        trades_df['rolling_winrate'] = trades_df['is_win'].rolling(window=window, min_periods=1).mean() * 100\n        \n        ax.plot(trades_df['exit_time'], trades_df['rolling_winrate'], \n               color=self.colors['profit'], linewidth=2, marker='o', markersize=4)\n        \n        # Zone de performance acceptable\n        ax.axhline(y=50, color=self.colors['neutral'], linestyle='--', alpha=0.7, label='Break-even 50%')\n        ax.fill_between(trades_df['exit_time'], 50, 100, alpha=0.1, color=self.colors['profit'])\n        ax.fill_between(trades_df['exit_time'], 0, 50, alpha=0.1, color=self.colors['loss'])\n        \n        ax.set_title('ðŸŽ¯ Win Rate Glissant', fontsize=14, fontweight='bold', color='white')\n        ax.set_xlabel('Temps', color='white')\n        ax.set_ylabel('Win Rate (%)', color='white')\n        ax.set_ylim(0, 100)\n        ax.legend()\n        ax.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax.tick_params(colors='white')\n    \n    def _plot_drawdown_analysis(self, ax, results):\n        \"\"\"Analyse des drawdowns\"\"\"\n        if not results['daily_pnl']:\n            return\n        \n        df = pd.DataFrame(results['daily_pnl'])\n        df['timestamp'] = pd.to_datetime(df['timestamp'])\n        \n        # Calcul du drawdown\n        df['running_max'] = df['total_value'].cummax()\n        df['drawdown'] = ((df['total_value'] - df['running_max']) / df['running_max']) * 100\n        \n        ax.fill_between(df['timestamp'], df['drawdown'], 0, \n                       color=self.colors['loss'], alpha=0.6)\n        ax.plot(df['timestamp'], df['drawdown'], \n               color=self.colors['loss'], linewidth=2)\n        \n        # Annotation du max drawdown\n        max_dd = df['drawdown'].min()\n        max_dd_date = df.loc[df['drawdown'].idxmin(), 'timestamp']\n        \n        ax.annotate(f'Max DD: {max_dd:.1f}%', \n                   xy=(max_dd_date, max_dd), \n                   xytext=(10, 10), textcoords='offset points',\n                   fontsize=10, fontweight='bold', color=self.colors['loss'],\n                   bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7),\n                   arrowprops=dict(arrowstyle='->', color=self.colors['loss']))\n        \n        ax.set_title('ðŸ“‰ Analyse Drawdown', fontsize=14, fontweight='bold', color='white')\n        ax.set_xlabel('Temps', color='white')\n        ax.set_ylabel('Drawdown (%)', color='white')\n        ax.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax.tick_params(colors='white')\n    \n    def _plot_volatility_performance(self, ax, data, results):\n        \"\"\"CorrÃ©lation volatilitÃ© vs performance\"\"\"\n        if not results['trades']:\n            return\n        \n        trades_df = pd.DataFrame(results['trades'])\n        trades_df['entry_time'] = pd.to_datetime(trades_df['entry_time'])\n        \n        # Merger avec donnÃ©es de volatilitÃ©\n        data_reset = data.reset_index()\n        data_reset['timestamp'] = pd.to_datetime(data_reset['timestamp'])\n        \n        merged = pd.merge_asof(trades_df.sort_values('entry_time'), \n                              data_reset.sort_values('timestamp'),\n                              left_on='entry_time', right_on='timestamp',\n                              direction='backward')\n        \n        if not merged.empty and 'volatility' in merged.columns:\n            # Scatter plot\n            colors = [self.colors['profit'] if pnl > 0 else self.colors['loss'] \n                     for pnl in merged['pnl_pct']]\n            \n            scatter = ax.scatter(merged['volatility'], merged['pnl_pct'], \n                               c=colors, alpha=0.7, s=60, edgecolors='white', linewidth=1)\n            \n            # Ligne de tendance\n            if len(merged) > 2:\n                z = np.polyfit(merged['volatility'], merged['pnl_pct'], 1)\n                p = np.poly1d(z)\n                ax.plot(merged['volatility'], p(merged['volatility']), \n                       color=self.colors['hedge'], linestyle='--', linewidth=2, alpha=0.8)\n        \n        ax.axhline(y=0, color=self.colors['neutral'], linestyle='-', alpha=0.7)\n        ax.set_title('ðŸ“ˆ VolatilitÃ© vs Performance', fontsize=14, fontweight='bold', color='white')\n        ax.set_xlabel('VolatilitÃ©', color='white')\n        ax.set_ylabel('PnL (%)', color='white')\n        ax.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax.tick_params(colors='white')\n    \n    def _plot_hedge_analysis(self, ax, results):\n        \"\"\"Analyse des opportunitÃ©s de hedge\"\"\"\n        if not results['hedge_opportunities']:\n            ax.text(0.5, 0.5, 'Aucune opportunitÃ©\\nde hedge dÃ©tectÃ©e', \n                   ha='center', va='center', transform=ax.transAxes,\n                   fontsize=12, color='white')\n            ax.set_title('ðŸ›¡ï¸ Analyse Hedge', fontsize=14, fontweight='bold', color='white')\n            return\n        \n        hedge_df = pd.DataFrame(results['hedge_opportunities'])\n        hedge_df['timestamp'] = pd.to_datetime(hedge_df['timestamp'])\n        \n        # Timeline des hedges\n        ax.scatter(hedge_df['timestamp'], hedge_df['position_strike'], \n                  color=self.colors['hedge'], s=100, alpha=0.8, \n                  marker='D', label='Hedge Opportunities')\n        \n        ax.set_title('ðŸ›¡ï¸ OpportunitÃ©s de Hedge', fontsize=14, fontweight='bold', color='white')\n        ax.set_xlabel('Temps', color='white')\n        ax.set_ylabel('Prix Strike', color='white')\n        ax.legend()\n        ax.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax.tick_params(colors='white')\n    \n    def _plot_performance_metrics(self, ax, results):\n        \"\"\"MÃ©triques de performance sous forme de tableau\"\"\"\n        ax.axis('off')\n        \n        # Calcul des mÃ©triques\n        metrics = {}\n        if results.get('total_trades', 0) > 0:\n            metrics['Total Trades'] = results['total_trades']\n            metrics['Win Rate'] = f\"{results.get('win_rate', 0):.1f}%\"\n            metrics['Avg PnL'] = f\"{results.get('avg_pnl', 0):.2f}%\"\n            metrics['Max Win'] = f\"{results.get('max_win', 0):.2f}%\"\n            metrics['Max Loss'] = f\"{results.get('max_loss', 0):.2f}%\"\n            metrics['Profit Factor'] = f\"{results.get('profit_factor', 0):.2f}\"\n            metrics['Sharpe Ratio'] = f\"{results.get('sharpe_ratio', 0):.2f}\"\n            metrics['Total Return'] = f\"{results.get('total_return', 0):.2f}%\"\n            \n            if results['hedge_opportunities']:\n                metrics['Hedges Detected'] = len(results['hedge_opportunities'])\n        \n        # CrÃ©ation du tableau\n        table_data = [[k, v] for k, v in metrics.items()]\n        \n        if table_data:\n            table = ax.table(cellText=table_data,\n                           colLabels=['MÃ©trique', 'Valeur'],\n                           cellLoc='center',\n                           loc='center',\n                           colWidths=[0.6, 0.4])\n            \n            table.auto_set_font_size(False)\n            table.set_fontsize(11)\n            table.scale(1, 2)\n            \n            # Style du tableau\n            for i in range(len(table_data) + 1):\n                for j in range(2):\n                    cell = table[(i, j)]\n                    if i == 0:  # Header\n                        cell.set_facecolor('#333333')\n                        cell.set_text_props(weight='bold', color='white')\n                    else:\n                        cell.set_facecolor('#1a1a1a')\n                        cell.set_text_props(color='white')\n                    cell.set_edgecolor('white')\n        \n        ax.set_title('ðŸ“Š MÃ©triques Performance', fontsize=14, fontweight='bold', color='white')\n    \n    def _create_trade_analysis_chart(self, results, output_dir, timestamp):\n        \"\"\"Graphique dÃ©taillÃ© d'analyse des trades\"\"\"\n        if not results['trades']:\n            return\n        \n        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))\n        fig.patch.set_facecolor(self.colors['background'])\n        \n        trades_df = pd.DataFrame(results['trades'])\n        \n        # 1. PnL par trade dans le temps\n        ax1.bar(range(len(trades_df)), trades_df['pnl_pct'], \n               color=[self.colors['profit'] if p > 0 else self.colors['loss'] for p in trades_df['pnl_pct']],\n               alpha=0.7, edgecolor='white', linewidth=1)\n        ax1.axhline(y=0, color=self.colors['neutral'], linestyle='-', alpha=0.7)\n        ax1.set_title('ðŸ“Š PnL par Trade', fontsize=14, fontweight='bold', color='white')\n        ax1.set_xlabel('NumÃ©ro Trade', color='white')\n        ax1.set_ylabel('PnL (%)', color='white')\n        ax1.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax1.tick_params(colors='white')\n        \n        # 2. DurÃ©e de dÃ©tention vs PnL\n        colors = [self.colors['profit'] if p > 0 else self.colors['loss'] for p in trades_df['pnl_pct']]\n        ax2.scatter(trades_df['holding_time'], trades_df['pnl_pct'], \n                   c=colors, alpha=0.7, s=60, edgecolors='white', linewidth=1)\n        ax2.axhline(y=0, color=self.colors['neutral'], linestyle='-', alpha=0.7)\n        ax2.set_title('â±ï¸ DurÃ©e vs PnL', fontsize=14, fontweight='bold', color='white')\n        ax2.set_xlabel('DurÃ©e (heures)', color='white')\n        ax2.set_ylabel('PnL (%)', color='white')\n        ax2.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax2.tick_params(colors='white')\n        \n        # 3. Raisons de sortie\n        exit_reasons = trades_df['exit_reason'].value_counts()\n        colors_pie = [self.colors['profit'], self.colors['loss'], self.colors['hedge'], self.colors['neutral']]\n        ax3.pie(exit_reasons.values, labels=exit_reasons.index, autopct='%1.1f%%',\n               colors=colors_pie[:len(exit_reasons)], startangle=90)\n        ax3.set_title('ðŸšª Raisons de Sortie', fontsize=14, fontweight='bold', color='white')\n        \n        # 4. Distribution par heure d'entrÃ©e\n        trades_df['entry_time'] = pd.to_datetime(trades_df['entry_time'])\n        trades_df['hour'] = trades_df['entry_time'].dt.hour\n        hour_performance = trades_df.groupby('hour')['pnl_pct'].mean()\n        \n        bars = ax4.bar(hour_performance.index, hour_performance.values,\n                      color=[self.colors['profit'] if p > 0 else self.colors['loss'] for p in hour_performance.values],\n                      alpha=0.7, edgecolor='white', linewidth=1)\n        ax4.axhline(y=0, color=self.colors['neutral'], linestyle='-', alpha=0.7)\n        ax4.set_title('ðŸ• Performance par Heure', fontsize=14, fontweight='bold', color='white')\n        ax4.set_xlabel('Heure', color='white')\n        ax4.set_ylabel('PnL Moyen (%)', color='white')\n        ax4.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax4.tick_params(colors='white')\n        \n        plt.tight_layout()\n        filename = f'{output_dir}/ultra_trade_analysis_{timestamp}.png'\n        plt.savefig(filename, dpi=300, bbox_inches='tight', \n                   facecolor=self.colors['background'], edgecolor='none')\n        print(f\"âœ… Analyse trades sauvegardÃ©e: {filename}\")\n        plt.show()\n    \n    def _create_risk_analysis_chart(self, results, output_dir, timestamp):\n        \"\"\"Graphique d'analyse des risques\"\"\"\n        if not results['daily_pnl']:\n            return\n        \n        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))\n        fig.patch.set_facecolor(self.colors['background'])\n        \n        df = pd.DataFrame(results['daily_pnl'])\n        df['timestamp'] = pd.to_datetime(df['timestamp'])\n        \n        # 1. VolatilitÃ© du capital\n        df['returns'] = df['total_value'].pct_change() * 100\n        df['volatility_20'] = df['returns'].rolling(20).std()\n        \n        ax1.plot(df['timestamp'], df['volatility_20'], \n                color=self.colors['hedge'], linewidth=2)\n        ax1.fill_between(df['timestamp'], df['volatility_20'], \n                        alpha=0.3, color=self.colors['hedge'])\n        ax1.set_title('ðŸ“Š VolatilitÃ© du Capital', fontsize=14, fontweight='bold', color='white')\n        ax1.set_xlabel('Temps', color='white')\n        ax1.set_ylabel('VolatilitÃ© 20j (%)', color='white')\n        ax1.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax1.tick_params(colors='white')\n        \n        # 2. Distribution des retours quotidiens\n        daily_returns = df['returns'].dropna()\n        if len(daily_returns) > 0:\n            ax2.hist(daily_returns, bins=20, alpha=0.7, color=self.colors['neutral'], \n                    edgecolor='white', linewidth=1)\n            ax2.axvline(daily_returns.mean(), color=self.colors['profit'], \n                       linestyle='-', linewidth=2, label=f'Moyenne: {daily_returns.mean():.2f}%')\n            ax2.axvline(0, color=self.colors['loss'], linestyle=':', \n                       linewidth=2, alpha=0.7)\n            ax2.set_title('ðŸ“ˆ Distribution Retours', fontsize=14, fontweight='bold', color='white')\n            ax2.set_xlabel('Retour Quotidien (%)', color='white')\n            ax2.set_ylabel('FrÃ©quence', color='white')\n            ax2.legend()\n            ax2.grid(True, alpha=0.3, color=self.colors['grid'])\n            ax2.tick_params(colors='white')\n        \n        # 3. CorrÃ©lation positions vs performance\n        ax3.scatter(df['num_positions'], df['returns'], \n                   alpha=0.6, color=self.colors['hedge'], s=40, edgecolors='white')\n        ax3.axhline(y=0, color=self.colors['neutral'], linestyle='-', alpha=0.7)\n        ax3.set_title('ðŸŽ¯ Positions vs Retours', fontsize=14, fontweight='bold', color='white')\n        ax3.set_xlabel('Nombre Positions', color='white')\n        ax3.set_ylabel('Retour (%)', color='white')\n        ax3.grid(True, alpha=0.3, color=self.colors['grid'])\n        ax3.tick_params(colors='white')\n        \n        # 4. Maximum Adverse Excursion (MAE) si trades disponibles\n        if results['trades']:\n            trades_df = pd.DataFrame(results['trades'])\n            # Approximation du MAE (en rÃ©alitÃ© besoin de donnÃ©es intraday)\n            mae_approx = trades_df['pnl_pct'].where(trades_df['pnl_pct'] < 0, 0)\n            \n            ax4.scatter(range(len(mae_approx)), mae_approx, \n                       color=self.colors['loss'], alpha=0.7, s=60)\n            ax4.axhline(y=0, color=self.colors['neutral'], linestyle='-', alpha=0.7)\n            ax4.set_title('ðŸ’” Maximum Adverse Excursion', fontsize=14, fontweight='bold', color='white')\n            ax4.set_xlabel('NumÃ©ro Trade', color='white')\n            ax4.set_ylabel('MAE (%)', color='white')\n            ax4.grid(True, alpha=0.3, color=self.colors['grid'])\n            ax4.tick_params(colors='white')\n        \n        plt.tight_layout()\n        filename = f'{output_dir}/ultra_risk_analysis_{timestamp}.png'\n        plt.savefig(filename, dpi=300, bbox_inches='tight', \n                   facecolor=self.colors['background'], edgecolor='none')\n        print(f\"âœ… Analyse risque sauvegardÃ©e: {filename}\")\n        plt.show()\n    \n    def generate_performance_report(self, results, output_dir='output'):\n        \"\"\"GÃ©nÃ¨re un rapport de performance dÃ©taillÃ©\"\"\"\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f'{output_dir}/ultra_performance_report_{timestamp}.txt'\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(\"=\" * 80 + \"\\n\")\n            f.write(\"ðŸš€ RAPPORT DE PERFORMANCE ULTRA-STRADDLE\\n\")\n            f.write(\"=\" * 80 + \"\\n\\n\")\n            \n            f.write(f\"ðŸ“… Date de gÃ©nÃ©ration: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\\n\\n\")\n            \n            # RÃ©sumÃ© exÃ©cutif\n            f.write(\"ðŸ“Š RÃ‰SUMÃ‰ EXÃ‰CUTIF\\n\")\n            f.write(\"-\" * 50 + \"\\n\")\n            f.write(f\"Capital final: ${results.get('final_capital', 0):,.2f}\\n\")\n            f.write(f\"Rendement total: {results.get('total_return', 0):.2f}%\\n\")\n            f.write(f\"Nombre de trades: {results.get('total_trades', 0)}\\n\")\n            f.write(f\"Taux de rÃ©ussite: {results.get('win_rate', 0):.1f}%\\n\\n\")\n            \n            # MÃ©triques dÃ©taillÃ©es\n            f.write(\"ðŸ“ˆ MÃ‰TRIQUES DÃ‰TAILLÃ‰ES\\n\")\n            f.write(\"-\" * 50 + \"\\n\")\n            f.write(f\"PnL moyen: {results.get('avg_pnl', 0):.2f}%\\n\")\n            f.write(f\"Meilleur trade: {results.get('max_win', 0):.2f}%\\n\")\n            f.write(f\"Pire trade: {results.get('max_loss', 0):.2f}%\\n\")\n            f.write(f\"Profit Factor: {results.get('profit_factor', 0):.2f}\\n\")\n            f.write(f\"Sharpe Ratio: {results.get('sharpe_ratio', 0):.2f}\\n\\n\")\n            \n            # Analyse des hedges\n            if results['hedge_opportunities']:\n                f.write(\"ðŸ›¡ï¸ ANALYSE DU HEDGING\\n\")\n                f.write(\"-\" * 50 + \"\\n\")\n                f.write(f\"OpportunitÃ©s dÃ©tectÃ©es: {len(results['hedge_opportunities'])}\\n\")\n                f.write(f\"FrÃ©quence moyenne: {len(results['hedge_opportunities']) / max(1, results.get('total_trades', 1)):.1f} par trade\\n\\n\")\n            \n            # Recommandations\n            f.write(\"ðŸ’¡ RECOMMANDATIONS\\n\")\n            f.write(\"-\" * 50 + \"\\n\")\n            \n            win_rate = results.get('win_rate', 0)\n            total_return = results.get('total_return', 0)\n            \n            if win_rate >= 60 and total_return > 10:\n                f.write(\"âœ… Performance excellente - StratÃ©gie recommandÃ©e pour trading live\\n\")\n            elif win_rate >= 50 and total_return > 5:\n                f.write(\"ðŸŸ¡ Performance acceptable - Optimisations mineures recommandÃ©es\\n\")\n            else:\n                f.write(\"ðŸ”´ Performance insuffisante - RÃ©vision majeure nÃ©cessaire\\n\")\n            \n            f.write(f\"\\nðŸŽ¯ Optimisations suggÃ©rÃ©es:\\n\")\n            if win_rate < 50:\n                f.write(\"- Resserrer les critÃ¨res d'entrÃ©e\\n\")\n            if results.get('max_loss', 0) < -50:\n                f.write(\"- RÃ©duire le stop loss\\n\")\n            if len(results.get('hedge_opportunities', [])) > results.get('total_trades', 1) * 0.5:\n                f.write(\"- ImplÃ©menter le hedging automatique\\n\")\n            \n            f.write(\"\\n\" + \"=\" * 80 + \"\\n\")\n            f.write(\"ðŸ“‹ Fin du rapport\\n\")\n        \n        print(f\"âœ… Rapport de performance sauvegardÃ©: {filename}\")\n        return filename
