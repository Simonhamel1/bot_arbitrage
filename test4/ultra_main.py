# Script Principal Ultra-Optimis√© pour Strat√©gie Straddle Rentable

import os
import warnings
import pandas as pd
import numpy as np
from datetime import datetime

# Configuration environnement
warnings.filterwarnings('ignore')
os.makedirs('output', exist_ok=True)

# Imports modules internes
from data_manager import DataManager
from ultra_straddle_strategy import UltraStraddleStrategy
from ultra_visualization import UltraVisualization
from config import *

def print_banner():
    """Affiche le banner de l'application"""
    print("=" * 80)
    print("üöÄ ULTRA STRADDLE BOT - VERSION RENTABLE")
    print("=" * 80)
    print("üéØ Objectif: Strat√©gie straddle ultra-optimis√©e avec hedging")
    print("üí∞ Risque max: Prime d'exercice uniquement")
    print("üõ°Ô∏è Protection: Positions Long/Short dynamiques")
    print("üìà Focus: Rentabilit√© maximale avec risque contr√¥l√©")
    print("=" * 80)

def print_config_summary():
    """Affiche un r√©sum√© de la configuration"""
    print("‚öôÔ∏è CONFIGURATION ULTRA-OPTIMIS√âE")
    print("-" * 50)
    print(f"üìä Symbole: {SYMBOL}")
    print(f"‚è∞ Timeframe: {TIMEFRAME}")
    print(f"üìÖ P√©riode: {BACKTEST_START_DATE} ‚Üí {BACKTEST_END_DATE}")
    print(f"üí∞ Capital initial: ${INITIAL_CAPITAL:,}")
    print(f"üéØ Risque par trade: {RISK_PER_TRADE:.1%}")
    print(f"üìà Take Profit: {TAKE_PROFIT_MULTIPLIER}x")
    print(f"üìâ Stop Loss: {STOP_LOSS_MULTIPLIER}x")
    print(f"üî• Seuil volatilit√©: {VOLATILITY_THRESHOLD}%")
    print(f"üõ°Ô∏è Hedging activ√©: {MOMENTUM_HEDGE}")
    print(f"üìä Positions max: {MAX_POSITIONS}")
    print("-" * 50)

def validate_risk_parameters():
    """Valide les param√®tres de risque"""
    print("üîç Validation des param√®tres de risque...")
    
    issues = []
    
    # V√©rification risque par trade
    if RISK_PER_TRADE > 0.05:
        issues.append(f"‚ö†Ô∏è Risque par trade √©lev√©: {RISK_PER_TRADE:.1%} > 5%")
    
    # V√©rification ratio TP/SL
    tp_sl_ratio = TAKE_PROFIT_MULTIPLIER / STOP_LOSS_MULTIPLIER
    if tp_sl_ratio < 1.5:
        issues.append(f"‚ö†Ô∏è Ratio TP/SL faible: {tp_sl_ratio:.1f} < 1.5")
    
    # V√©rification seuil volatilit√©
    if VOLATILITY_THRESHOLD < 30:
        issues.append(f"‚ö†Ô∏è Seuil volatilit√© tr√®s bas: {VOLATILITY_THRESHOLD}%")
    
    # V√©rification coh√©rence dates
    start_date = pd.to_datetime(BACKTEST_START_DATE)
    end_date = pd.to_datetime(BACKTEST_END_DATE)
    if (end_date - start_date).days < 30:
        issues.append("‚ö†Ô∏è P√©riode de backtest tr√®s courte < 30 jours")
    
    if issues:
        print("‚ö†Ô∏è Avertissements d√©tect√©s:")
        for issue in issues:
            print(f"   {issue}")
        print("   ‚Üí Continuez uniquement si vous acceptez ces risques")
        input("   Appuyez sur Entr√©e pour continuer...")
    else:
        print("‚úÖ Tous les param√®tres de risque sont valid√©s")

def calculate_theoretical_max_loss():
    """Calcule la perte maximale th√©orique"""
    max_premium = INITIAL_CAPITAL * RISK_PER_TRADE
    max_simultaneous_loss = max_premium * MAX_POSITIONS
    
    print(f"üí∞ ANALYSE RISQUE TH√âORIQUE")
    print(f"   Prime max par position: ${max_premium:,.2f}")
    print(f"   Perte max simultan√©e: ${max_simultaneous_loss:,.2f}")
    print(f"   % du capital: {(max_simultaneous_loss/INITIAL_CAPITAL)*100:.1f}%")
    
    return max_simultaneous_loss

def run_ultra_straddle_analysis():
    """Lance l'analyse ultra-compl√®te de la strat√©gie straddle"""
    
    # 1. Banner et configuration
    print_banner()
    print_config_summary()
    
    # 2. Validation des risques
    validate_risk_parameters()
    max_theoretical_loss = calculate_theoretical_max_loss()
    
    print("\nüöÄ D√âMARRAGE ANALYSE ULTRA-STRADDLE...")
    
    try:
        # 3. R√©cup√©ration des donn√©es
        print("\nüìä √âTAPE 1/5: R√©cup√©ration des donn√©es")
        data_manager = DataManager()
        data = data_manager.get_data()
        
        if data.empty:
            print("‚ùå Erreur: Aucune donn√©e r√©cup√©r√©e")
            return None
        
        print(f"‚úÖ {len(data)} barres de donn√©es r√©cup√©r√©es")
        print(f"   P√©riode: {data.index[0].strftime('%Y-%m-%d')} ‚Üí {data.index[-1].strftime('%Y-%m-%d')}")
        print(f"   Volatilit√© moyenne: {data['volatility'].mean():.2%}")
        print(f"   Range de prix: ${data['close'].min():,.0f} - ${data['close'].max():,.0f}")
        
        # 4. Ex√©cution de la strat√©gie ultra-optimis√©e
        print("\nüéØ √âTAPE 2/5: Ex√©cution strat√©gie ultra-optimis√©e")
        strategy = UltraStraddleStrategy()
        
        # Filtrer les donn√©es pour la p√©riode de backtest
        backtest_data = data[(data.index >= BACKTEST_START_DATE) & (data.index < BACKTEST_END_DATE)]
        
        if backtest_data.empty:
            print("‚ùå Erreur: Aucune donn√©e pour la p√©riode de backtest")
            return None
        
        print(f"üìä Donn√©es backtest: {len(backtest_data)} barres")
        results = strategy.run_ultra_backtest(backtest_data)\n        \n        # 5. Analyse des r√©sultats\n        print(\"\\nüìà √âTAPE 3/5: Analyse des r√©sultats\")\n        \n        if results['total_trades'] == 0:\n            print(\"‚ö†Ô∏è Aucun trade ex√©cut√© - Crit√®res d'entr√©e trop stricts\")\n            print(\"üí° Suggestions:\")\n            print(\"   - R√©duire VOLATILITY_THRESHOLD\")\n            print(\"   - Ajuster les crit√®res d'entr√©e\")\n            print(\"   - V√©rifier la p√©riode de donn√©es\")\n            return results\n        \n        # Calcul m√©triques avanc√©es\n        winning_trades = [t for t in results['trades'] if t['pnl'] > 0]\n        losing_trades = [t for t in results['trades'] if t['pnl'] <= 0]\n        \n        avg_hold_time = np.mean([t['holding_time'] for t in results['trades']])\n        \n        # Analyse de la rentabilit√©\n        total_return = results['total_return']\n        win_rate = results.get('win_rate', 0)\n        \n        print(f\"üéØ Performance globale:\")\n        print(f\"   üìä {results['total_trades']} trades ex√©cut√©s\")\n        print(f\"   üìà Rendement: {total_return:.2f}%\")\n        print(f\"   üéØ Taux r√©ussite: {win_rate:.1f}%\")\n        print(f\"   ‚è±Ô∏è Dur√©e moyenne: {avg_hold_time:.1f}h\")\n        \n        if len(winning_trades) > 0:\n            print(f\"   üí∞ Trades gagnants: {len(winning_trades)} (avg: {np.mean([t['pnl_pct'] for t in winning_trades]):.1f}%)\")\n        if len(losing_trades) > 0:\n            print(f\"   üíî Trades perdants: {len(losing_trades)} (avg: {np.mean([t['pnl_pct'] for t in losing_trades]):.1f}%)\")\n        \n        # Analyse du hedging\n        if results['hedge_opportunities']:\n            hedge_count = len(results['hedge_opportunities'])\n            hedge_frequency = hedge_count / results['total_trades']\n            print(f\"   üõ°Ô∏è Hedges d√©tect√©s: {hedge_count} ({hedge_frequency:.1f} par trade)\")\n        \n        # 6. √âvaluation de la rentabilit√©\n        print(\"\\nüí∞ √âVALUATION RENTABILIT√â\")\n        print(\"-\" * 40)\n        \n        is_profitable = total_return > 5  # Minimum 5% de retour\n        is_consistent = win_rate >= 50   # Minimum 50% de r√©ussite\n        is_efficient = results.get('sharpe_ratio', 0) > 1  # Sharpe > 1\n        \n        if is_profitable and is_consistent:\n            print(\"‚úÖ STRAT√âGIE RENTABLE CONFIRM√âE\")\n            print(f\"   üéØ Objectif de rentabilit√© atteint: {total_return:.1f}% > 5%\")\n            print(f\"   üéØ Consistance valid√©e: {win_rate:.1f}% ‚â• 50%\")\n            \n            if is_efficient:\n                print(f\"   üéØ Efficacit√© excellente: Sharpe {results.get('sharpe_ratio', 0):.2f} > 1\")\n            \n            # Calcul du risque r√©el vs th√©orique\n            real_max_loss = min([t['pnl_pct'] for t in results['trades']]) if results['trades'] else 0\n            print(f\"   üõ°Ô∏è Perte max r√©elle: {real_max_loss:.1f}% (vs th√©orique: {-(STOP_LOSS_MULTIPLIER*100):.0f}%)\")\n            \n        elif is_profitable:\n            print(\"üü° STRAT√âGIE PARTIELLEMENT RENTABLE\")\n            print(f\"   ‚úÖ Rentabilit√© OK: {total_return:.1f}%\")\n            print(f\"   ‚ö†Ô∏è Consistance faible: {win_rate:.1f}% < 50%\")\n            print(\"   üí° Am√©lioration sugg√©r√©e: resserrer crit√®res d'entr√©e\")\n            \n        else:\n            print(\"üî¥ STRAT√âGIE NON RENTABLE\")\n            print(f\"   ‚ùå Rendement insuffisant: {total_return:.1f}% < 5%\")\n            print(f\"   ‚ùå Win rate: {win_rate:.1f}%\")\n            print(\"   üí° R√©vision majeure n√©cessaire\")\n        \n        # 7. Visualisations ultra-avanc√©es\n        print(\"\\nüé® √âTAPE 4/5: G√©n√©ration visualisations ultra-avanc√©es\")\n        visualizer = UltraVisualization()\n        \n        dashboard_file = visualizer.create_ultra_performance_dashboard(\n            backtest_data, results, 'output'\n        )\n        \n        report_file = visualizer.generate_performance_report(results, 'output')\n        \n        # 8. Recommandations finales\n        print(\"\\nüí° √âTAPE 5/5: Recommandations finales\")\n        print(\"-\" * 50)\n        \n        if is_profitable and is_consistent:\n            print(\"üöÄ RECOMMANDATIONS POUR TRADING LIVE:\")\n            print(\"   ‚úÖ Strat√©gie pr√™te pour impl√©mentation\")\n            print(f\"   üí∞ Capital recommand√©: ${INITIAL_CAPITAL:,} minimum\")\n            print(f\"   üéØ Risque par trade maintenu: {RISK_PER_TRADE:.1%}\")\n            print(f\"   üõ°Ô∏è Hedging: {'Activ√©' if MOMENTUM_HEDGE else 'D√©sactiv√©'}\")\n            \n            if results['hedge_opportunities']:\n                print(\"   üî• Impl√©menter le hedging automatique pour optimiser\")\n            \n            print(\"   ‚ö†Ô∏è Surveillance requise: volatilit√© et corr√©lations\")\n            \n        else:\n            print(\"‚ö†Ô∏è RECOMMANDATIONS D'OPTIMISATION:\")\n            \n            if not is_profitable:\n                print(\"   üîß Ajuster TAKE_PROFIT_MULTIPLIER √† 1.8\")\n                print(\"   üîß R√©duire STOP_LOSS_MULTIPLIER √† 0.5\")\n                print(\"   üîß Augmenter VOLATILITY_THRESHOLD √† 70\")\n            \n            if not is_consistent:\n                print(\"   üîß Resserrer crit√®res d'entr√©e (signal_quality >= 0.85)\")\n                print(\"   üîß R√©duire MAX_POSITIONS √† 1 pour focus qualit√©\")\n                print(\"   üîß Activer ADAPTIVE_POSITION_SIZING\")\n            \n            print(\"   üîÑ Relancer l'analyse apr√®s ajustements\")\n        \n        # 9. R√©sum√© final avec focus risque\n        print(\"\\n\" + \"=\" * 80)\n        print(\"üéØ R√âSUM√â FINAL - GESTION DU RISQUE\")\n        print(\"=\" * 80)\n        print(f\"üí∞ Capital final: ${results['final_capital']:,.2f}\")\n        print(f\"üìà Performance: {total_return:.2f}% ({('PROFITABLE' if is_profitable else 'NON PROFITABLE')})\")\n        print(f\"üõ°Ô∏è Risque max encouru: Prime d'exercice uniquement\")\n        print(f\"üìä Perte max r√©elle: {min([t['pnl_pct'] for t in results['trades']], default=0):.1f}%\")\n        print(f\"üéØ Objectif atteint: {'OUI' if is_profitable and is_consistent else 'NON'}\")\n        \n        if MOMENTUM_HEDGE and results['hedge_opportunities']:\n            print(f\"üõ°Ô∏è Positions Long/Short: {len(results['hedge_opportunities'])} opportunit√©s d√©tect√©es\")\n            print(\"üìã Le hedging dynamique a permis de limiter l'exposition directionnelle\")\n        \n        print(\"=\" * 80)\n        \n        return results\n        \n    except Exception as e:\n        print(f\"‚ùå Erreur critique: {str(e)}\")\n        import traceback\n        traceback.print_exc()\n        return None\n\ndef main():\n    \"\"\"Fonction principale\"\"\"\n    start_time = datetime.now()\n    \n    try:\n        results = run_ultra_straddle_analysis()\n        \n        if results:\n            end_time = datetime.now()\n            execution_time = (end_time - start_time).total_seconds()\n            \n            print(f\"\\n‚è±Ô∏è Analyse termin√©e en {execution_time:.1f} secondes\")\n            print(f\"üìÅ Fichiers g√©n√©r√©s dans le dossier 'output/'\")\n            print(f\"üìä Dashboard, graphiques et rapport disponibles\")\n            \n            # Proposition d'optimisation automatique\n            if results.get('total_return', 0) < 5 or results.get('win_rate', 0) < 50:\n                print(\"\\nüîß OPTIMISATION AUTOMATIQUE DISPONIBLE\")\n                response = input(\"Voulez-vous lancer une optimisation automatique des param√®tres? (o/N): \")\n                if response.lower() == 'o':\n                    print(\"üöÄ Lancement optimisation automatique...\")\n                    # TODO: Impl√©menter optimisation automatique\n                    print(\"‚ö†Ô∏è Fonctionnalit√© en d√©veloppement\")\n        \n        print(\"\\nüéØ Session termin√©e avec succ√®s!\")\n        \n    except KeyboardInterrupt:\n        print(\"\\n‚ö†Ô∏è Analyse interrompue par l'utilisateur\")\n    except Exception as e:\n        print(f\"\\n‚ùå Erreur fatale: {str(e)}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    main()
